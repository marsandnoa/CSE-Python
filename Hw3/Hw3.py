"""Template for Homework 4 in CSE 4256 at The Ohio State University.

Date: Feb 7, 2022
Author: Alan Weide

Due date: Feb 13, 2022
"""

# ----------------
#  Argument Types
# ----------------

def printargs0(x, y=0, /, *, z, w):
	print(f"{x = }")
	print(f"{y = }")
	print(f"{z = }")
	print(f"{w = }")

# TODO call the function printargs0
printargs0(1,2,3,4)

# TODO change the signature of printargs1 to take four arguments, all with default values
def printargs1(w=0,x=0,y=0,z=0):
  print(f"{w=}")
  print(f"{x=}")
  print(f"{y=}")
  print(f"{z=}")
	# TODO implement the body of printargs1 to print the name and value of each argument

# TODO call the function printargs1
printargs1()

# TODO change the signature of printargs2 to take:
#   * one positional-only argument
#   * two positional-or-keyword arguments
#   * three keyword-only arguments
def printargs2(v1,/,v2,v3,*,v5,v6,v7):
	# TODO implement the body of printargs2 to print the name and value of each argument
  print(f"{v1=}")
  print(f"{v2=}")
  print(f"{v3=}")
  print(f"{v4=}")
  print(f"{v5=}")
  print(f"{v6=}")
  print(f"{v7=}")

# TODO call the function printargs2
printargs2(1,2,3,4,5,6,7)

# TODO change the signature of printargs3 to take four positional-only arguments
def printargs3(v1,v2,v3,v4,/):
  print(f"{v1=}")
  print(f"{v2=}")
  print(f"{v3=}")
  print(f"{v4=}")
  
	# TODO implement the body of printargs3 to print the name and value of each argument

# TODO call the function printargs3
printargs3(1,2,3,4)

# TODO change the signature of printargs4 to take a variadic argument list
def printargs4(*args):
  for arg in args:
    print(f"{arg=}")
	# TODO implement the body of printargs4 to print the value of each argument

printargs4(1,2,3,4,5,6,7,8)
# TODO call the function printargs4
# TODO change the signature of printargs5 to take a keyword-variadic argument

def printargs5(**args):
    for arg in args:
      print(f"{arg=}")
	# TODO implement the body of printargs5 to print the name and value of each argument

printargs5({key1: 1, key2: 2})

# --------------
#  Dictionaries
# --------------

"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.
Uses a for-in loop.

Args:
  keys: the list of keys
  values: the list of values
"""
def build_dict1(keys, values):
  output=dict()
  for i in keys:
    output[i]=values[i]
  return output
	# TODO implement this function

"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.

Uses a dictionary comprehension.

Args:
  keys: the list of keys
  values: the list of values
"""
def build_dict2(keys, values):
	return {keys[i]: values[i] for i in values}

"""Returns a dictionary in which each item in `keys` maps to the corresponding item in `values`.

Uses the built-in `zip(seq1, seq2)` function.

Args:
  keys: the list of keys
  values: the list of values
"""
def build_dict3(keys, values):
	return dict(zip(keys, values))


"""Returns a dictionary which maps each letter to the number of times it appears in `s`.

Args:
  s: the string in which to search
"""
def letter_freq(s: str) -> dict:
  s=s.upper()
  output=dict()
  for i in str:
    output[str[i]]= output[str[i]]+1
  

"""Returns the letter in `s` that appears most often.

Args:
  s: the string in which to search
"""
def popular_letter(s: str) -> str:
	# TODO Implement this function
  s=s.upper()
  holder = Counter(test_str)
  holder = max(holder, key = holder.get) 

# ------------------------
#  Generators and Lambdas
# ------------------------

"""Generates the series identified by the Collatz Conjecture starting at `x`.

Args:
  x: the starting number
"""
def collatz(x):
  yield x
  while x!=1:
    if(x%2)!=0:
      x=x/2
    else:
      x=x*3+1
    yield x

	# TODO implement this generator function

"""Returns the length of the series generated by `collatz(x)`."""
def collatz_len(x):
  output=0
  for i in collatz(x):
    output=output+1
	# TODO implement this function
  return output

"""Generates the sequence of words in string `s`."""
def words(s):
  count=len(s)
  index=0;
  start=0;
  while len(s)!=index:
    index=index+1
    if(""==s[index]) or index==len(s):
      if(len(s)==index):
        yield s[start,index-1]
      else:
        yield s[start,index-2]
        start=index
	# TODO implement this generator function

"""Returns a list created by applying the single-argument function `f` to each item in `lst`.

Args:
  lst: the list
  f: a single-argument function that is applicable to each item in lst
"""
def mapped_list(lst, f):
	for i in lst:
    lst[i]=f(lst[i])

# TODO Call `mapped_list` with a lambda expression such that the generated list consists of the 
#   length of the Collatz Conjecture seires generated starting at the corresponding number in `lst`.
desired= lambda x: collatz_len(x)
mapped_list([1,2,3,4,5,6],desired)

# ----------------------
#  Challenge Activities
# ----------------------

# TODO Fiddle with the apparently-arbitrary values in the `mcg` function and see if the results can
#   be made significantly better or worse by changing them.

"""Simple pseudorandom number generator."""
def mcg(s=543718):
    x = s
    a = 48271
    c = 1
    m = 2147483647
    while True:
        x = (a*x + c) % m
        yield x

"""Simulates rolling a `sides`-sided die `samples` times, and prints the results.

Args:
  sides: number of sides on the die to simulate
  samples: number of rolls to simulate
"""
def diceroller(sides=6, samples=10000):
	die = (n % sides + 1 for n in mcg())
    counts = dict()
    for i in range(samples):
        roll = next(die)
        if roll not in counts:
            counts[roll] = 0
        counts[roll] += 1
            
    # TODO Modify the output of this function so that it displays a "pretty" horizontal bar chart.
    #   Hint: use the Unicode character FULL BLOCK (U+2588) (in Python: u"\u2588").
    for value in range(1, sides + 1):
        print(f"{value}: {counts[value]}")

